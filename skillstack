#!/usr/bin/env -S uv run --script
"""
Skillstack CLI entry point.

Run `./skillstack --help` to learn how the tool helps install skills for Codex.
"""

from __future__ import annotations

import argparse
import os
import shutil
from pathlib import Path
from typing import Iterable, Tuple, Dict


def repo_skills_dir() -> Path:
    return Path(__file__).resolve().parent / "skills"


def detect_cli() -> str:
    """
    Auto-detect which CLI is currently running.

    Returns:
        "claude" if running in Claude Code, "codex" if running in Codex CLI
    """
    # Claude Code sets CLAUDE_CODE_ENTRYPOINT environment variable
    if os.environ.get("CLAUDE_CODE_ENTRYPOINT"):
        return "claude"

    # Codex CLI sets CODEX_MANAGED_BY_NPM=1 environment variable
    if os.environ.get("CODEX_MANAGED_BY_NPM") == "1":
        return "codex"

    # If neither is detected, check which directory exists
    claude_dir = Path.home() / ".claude" / "skills"
    codex_dir = Path.home() / ".codex" / "skills"

    if claude_dir.exists() and not codex_dir.exists():
        return "claude"
    elif codex_dir.exists() and not claude_dir.exists():
        return "codex"

    # Default to Codex CLI if can't determine
    return "codex"


def target_skills_dir(target: str = "auto") -> Path:
    """
    Get the skills directory for a specific target.

    Args:
        target: "codex", "claude", "shared", or "auto" (auto-detect)

    Returns:
        Path to the target skills directory
    """
    if target == "auto":
        target = detect_cli()

    if target == "codex":
        return Path.home() / ".codex" / "skills"
    elif target == "claude":
        return Path.home() / ".claude" / "skills"
    elif target == "shared":
        # Use .claude as the standard shared location
        return Path.home() / ".claude" / "skills"
    else:
        raise ValueError(f"Unknown target: {target}")


def discover_skills(skills_root: Path) -> list[Path]:
    if not skills_root.exists():
        return []
    return [
        entry
        for entry in skills_root.iterdir()
        if entry.is_dir() and (entry / "SKILL.md").exists()
    ]


def check_existing_skills(skills: Iterable[Path], destination_root: Path) -> list[str]:
    """Check which skills already exist in the destination directory."""
    existing = []
    for skill_path in skills:
        target_path = destination_root / skill_path.name
        if target_path.exists():
            existing.append(skill_path.name)
    return existing


def install_skills(skills: Iterable[Path], destination_root: Path) -> list[Path]:
    destination_root.mkdir(parents=True, exist_ok=True)
    installed_paths: list[Path] = []
    for skill_path in skills:
        target_path = destination_root / skill_path.name
        shutil.copytree(skill_path, target_path, dirs_exist_ok=True)
        installed_paths.append(target_path)
    return installed_paths


def bootstrap_cmd(args: argparse.Namespace) -> None:
    """Bootstrap skills to target location(s)."""
    skills_root = repo_skills_dir()
    all_skills = discover_skills(skills_root)
    if not all_skills:
        raise SystemExit(f"No skills found in {skills_root}")

    # Filter skills if specific ones were requested
    requested_skills = getattr(args, 'skills', [])
    skipped_skills = getattr(args, 'skip', [])

    # Validate that skills and skip are not both specified
    if requested_skills and skipped_skills:
        print("ERROR: Cannot use both positional skills and --skip at the same time.")
        print("Use either:")
        print("  - Specify skills to install: skillstack bootstrap skill1 skill2")
        print("  - Skip specific skills: skillstack bootstrap --skip skill1 skill2")
        raise SystemExit(1)

    available_skill_names = {skill.name for skill in all_skills}

    if requested_skills:
        # Filter to only requested skills
        invalid_skills = [name for name in requested_skills if name not in available_skill_names]

        if invalid_skills:
            print(f"ERROR: The following skills were not found in {skills_root}:")
            for name in invalid_skills:
                print(f"  - {name}")
            print(f"\nAvailable skills: {', '.join(sorted(available_skill_names))}")
            raise SystemExit(1)

        skills = [skill for skill in all_skills if skill.name in requested_skills]
    elif skipped_skills:
        # Filter out skipped skills
        invalid_skills = [name for name in skipped_skills if name not in available_skill_names]

        if invalid_skills:
            print(f"WARNING: The following skills to skip were not found:")
            for name in invalid_skills:
                print(f"  - {name}")
            print(f"\nAvailable skills: {', '.join(sorted(available_skill_names))}")

        skills = [skill for skill in all_skills if skill.name not in skipped_skills]

        if not skills:
            print("ERROR: All skills were skipped. Nothing to install.")
            raise SystemExit(1)

        print(f"Skipping: {', '.join(skipped_skills)}")
    else:
        skills = all_skills

    target = getattr(args, 'target', 'auto')
    force = getattr(args, 'force', False)
    targets = []

    if target == "auto":
        detected = detect_cli()
        targets = [detected]
        print(f"Auto-detected CLI: {detected}")
    elif target == "both":
        targets = ["codex", "claude"]
    else:
        targets = [target]

    # Check for existing skills across all targets
    conflicts_by_target = {}
    for t in targets:
        dest = target_skills_dir(t)
        existing = check_existing_skills(skills, dest)
        if existing:
            conflicts_by_target[t] = existing

    # If there are conflicts and --force not provided, show warning and exit
    if conflicts_by_target and not force:
        skill_names_str = " ".join(requested_skills) if requested_skills else ""
        print("WARNING: The following skills already exist and will be OVERWRITTEN:\n")
        for t, existing_skills in conflicts_by_target.items():
            print(f"{t}:")
            for skill_name in existing_skills:
                skill_path = target_skills_dir(t) / skill_name
                print(f"  - {skill_name} ({skill_path})")

        print("\nThis will replace any custom modifications you may have made.")
        print("To proceed, run the command again with --force flag:")
        if requested_skills:
            print(f"  skillstack bootstrap {skill_names_str} --target {target} --force")
        else:
            print(f"  skillstack bootstrap --target {target} --force")
        raise SystemExit(1)

    # Proceed with installation
    for t in targets:
        dest = target_skills_dir(t)
        installed = install_skills(skills, dest)
        print(f"\nInstalled to {t}:")
        for path in installed:
            # Show if it was overwritten or newly installed
            was_overwritten = path.name in conflicts_by_target.get(t, [])
            status = "⚠ OVERWRITTEN" if was_overwritten else "✓"
            print(f"  {status} {path.name} -> {path}")


def _parse_skill_file(skill_path: Path) -> Tuple[Dict[str, str], str]:
    skill_file = skill_path / "SKILL.md"
    if not skill_file.exists():
        raise FileNotFoundError(f"Missing SKILL.md in {skill_path}")
    lines = skill_file.read_text(encoding="utf-8").splitlines()
    if not lines or lines[0].strip() != "---":
        return {}, "\n".join(lines).strip()
    metadata: dict[str, str] = {}
    idx = 1
    while idx < len(lines):
        stripped = lines[idx].strip()
        if stripped == "---":
            idx += 1
            break
        if stripped and ":" in stripped:
            key, value = stripped.split(":", 1)
            metadata[key.strip()] = value.strip()
        idx += 1
    body = "\n".join(lines[idx:]).strip()
    return metadata, body


def parse_skill_frontmatter(skill_path: Path) -> Tuple[str, str]:
    """Extract name/description from the SKILL.md frontmatter."""
    try:
        metadata, _ = _parse_skill_file(skill_path)
    except FileNotFoundError:
        return skill_path.name, ""
    return metadata.get("name", skill_path.name), metadata.get("description", "")


def load_skill(skill_slug: str) -> Tuple[str, str, str, str]:
    """Return (slug, name, description, body) for an installed skill."""
    # Try multiple locations
    for target in ["claude", "codex"]:
        skill_path = target_skills_dir(target) / skill_slug
        if skill_path.exists():
            metadata, body = _parse_skill_file(skill_path)
            return (
                skill_slug,
                metadata.get("name", skill_path.name),
                metadata.get("description", ""),
                body or "This skill has no prompt body.",
            )

    # If not found anywhere
    raise FileNotFoundError(
        f"Skill '{skill_slug}' is not installed in ~/.claude/skills or ~/.codex/skills"
    )


def list_cmd(_: argparse.Namespace) -> None:
    # Check both locations
    all_skills = []
    seen = set()

    for target in ["claude", "codex"]:
        skills = discover_skills(target_skills_dir(target))
        for skill in skills:
            if skill.name not in seen:
                all_skills.append(skill)
                seen.add(skill.name)

    if not all_skills:
        print("No skills installed. Run `skillstack bootstrap` first.")
        return

    for skill in sorted(all_skills, key=lambda path: path.name):
        skill_name, description = parse_skill_frontmatter(skill)
        if description:
            print(f"- {skill_name}: {description}")
        else:
            print(f"- {skill_name}")


def use_cmd(args: argparse.Namespace) -> None:
    slug = args.slug
    try:
        _slug, name, description, body = load_skill(slug)
    except FileNotFoundError as exc:
        raise SystemExit(str(exc))
    print(f"{name}")
    if description:
        print(description)
    print("\n" + body)


def init_cmd(args: argparse.Namespace) -> None:
    """Copy AGENTS.md template to current working directory."""
    template_path = Path(__file__).resolve().parent / "templates" / "AGENTS.md"
    target_path = Path.cwd() / "AGENTS.md"

    if not template_path.exists():
        raise SystemExit(f"Template not found: {template_path}")

    if target_path.exists():
        print(f"AGENTS.md already exists in {Path.cwd()}")
        print("Skipping. Remove the existing file first if you want to reinitialize.")
        return

    shutil.copy(template_path, target_path)
    print(f"✓ Created AGENTS.md in {Path.cwd()}")
    print("\nNext steps:")
    print("  1. Codex CLI will automatically discover and use skills based on AGENTS.md")
    print("  2. Check available skills: ~/.skillstack/skillstack list")
    print("  3. Start using Codex in this directory!")


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="skillstack",
        description=(
            "Skillstack installs skills for Codex CLI and Claude Code. "
            "Use this CLI to discover, install, and manage skill bundles."
        ),
    )
    subparsers = parser.add_subparsers(dest="command")
    bootstrap_parser = subparsers.add_parser(
        "bootstrap",
        help="Install bundled skills into target directory",
    )
    bootstrap_parser.add_argument(
        "skills",
        nargs="*",
        help="Specific skill(s) to install (install all if not specified)",
    )
    bootstrap_parser.add_argument(
        "--target",
        choices=["codex", "claude", "both", "auto"],
        default="auto",
        help="Target location (default: auto-detect)",
    )
    bootstrap_parser.add_argument(
        "--skip",
        nargs="+",
        metavar="SKILL",
        help="Skip specific skill(s) during installation",
    )
    bootstrap_parser.add_argument(
        "--force",
        action="store_true",
        help="Force overwrite of existing skills without prompting",
    )
    bootstrap_parser.set_defaults(func=bootstrap_cmd)
    list_parser = subparsers.add_parser(
        "list",
        help="List installed skills from ~/.claude/skills and ~/.codex/skills",
    )
    list_parser.set_defaults(func=list_cmd)
    use_parser = subparsers.add_parser(
        "use",
        help="Print the prompt/instructions for a skill slug",
    )
    use_parser.add_argument("slug", help="Skill slug present in ~/.claude/skills or ~/.codex/skills")
    use_parser.set_defaults(func=use_cmd)
    init_parser = subparsers.add_parser(
        "init",
        help="Copy AGENTS.md template to current directory for Codex CLI",
    )
    init_parser.set_defaults(func=init_cmd)
    return parser


def main() -> None:
    parser = build_parser()
    args = parser.parse_args()
    if hasattr(args, "func"):
        args.func(args)
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
